//private으로 함수를 감춰서, 필요한 메소드만 보이도록 간략화(추상화) 시킨다.
---
// private firstName ='';
        constructor(private firstName: string, public lastName: string) { // 알아서 상태값으로 저장.
            // this.firstName = firstName;
        }
---
// 행위를 통해 상태를 결정한다. 고양이의 기분을 직접 바꿀 수 없다. 놀아줘야한다.
private constructor(){} // private 하면 new로 만들지 못함.
                                        
                                        // 생성자가 아닌, static으로 인스턴스를 만드는 이유.
    static makeMachine():CoffeeMachine{ // 생성주기 관리: 싱글톤패턴,인스턴스갯수제한,등 컨틀롤 가능
        return new CoffeeMachine;       // 로직 캡슐화: 인스턴스 생성시 복잡한 로직이 있다면 간단하게 만들어줌
        
    }
---
상속받은 클래스는 모든 interface의 메소드를 구현한다.
interface 타입을 설정하면, interface안에 명시된 메소드만 사용할 수 있다. (메소드를 제한한다!)
즉 말그대로 사용자에게 어떤 인터페이스를 제공할지 결정 하는 것!
먼저 interface로 어떤 행위가 필요한지 생각하고
클래스 안에서 비지니스 로직을 작성! 사용자에게는 interface를 제공!
사용자는 비지니스 로직을 알 필요도 없고, 제공된 메소드를 사용할줄만 알면 된다.
=> 로직에 영향을 못줌 => 사이드이펙트 X => 유지보수 용이

inheritance -> 커피라떼머신은.. interface에 makeLatte를 추가해도 되겠지만
그냥 상속받아서 makeCoffee를 수정해줘도 되긴 하는구나. 그리고 이게 옳은 방법이고.
extends , protect 사용, 메소드를 overwritng(오버라이딩)
오버라이딩-> 완전히 바꿀수도, 부모의 것에 더하는 방식으로도 쓸 수 있다. (super.method())
생성자 초기화시에는 무조건 부모의 생성자를 받아온다,애초에 메소드도 전부다 가지고있음. super();

---3-6다형성
커피컵을 수정하고, makeCoffee를 재사용하지 못함.. 이러면 안돼..
이유는? 모든 클래스 내부의 커피컵을 수정해야하며, 코드의 메소드명을 수정해줘야함.
--> 커피컵을 상속받은 설탕커피컵..? 에효
=> 커피컵에 옵셔널로 sugar를 추가해주면 다른 클래스에서 일일히 쓸필요가 없다.
그리고 애초에 전부다 머신 하나에서 상속 받은 클래스들이라면
머신의 커피컵에서만 sugar를 적어주면 된다.
---
상속의 문제점? 모르겠는데
-> extends가 하나만 가능하며, 두개이상 된다고 하더라도 부모클래스 수정시 모든 자식클래스에 사이드이팩트 가능성
-> 깊이가 깊어질수록 관계가 복잡해지며 사이드이팩트 트러블
=> Composition 사용(구성요소들) :
   필요한 기능들을 매번 코드로 작성하지 않고, 한번 정의 후 가져다 쓰는 것 DI라고도 부른다.
	 기능을 따로 빼서 정의하면 코드 중복을 방지할 뿐 아니라, 활용도도 높아진다. (4-17챕터 3-7composition)

	 머신 클래스는 설탕을 어디서 가져오는지, 우유를 어떻게 만드는지 전혀 상관하지 않는다. (알필요없어야한다!)
	 단점: 기능에 너무 타이트하게 커플링되어있다. -> 항상 그 기능만 써야하며, 다른 기능을 사용하고 싶을때 모든 클래스를 수정해야함.
   클래스끼리 서로 잘 알고 지내는 것은 좋지 않다.
	 클래스 자신을 노출하지 않고 계약서(interface)를 통해 상호작용한다. (디커플링)
	 (로직 상관없이 반환값만 정의해놓았기때문에 조건맞 맞추어준다면 자유롭게 수정 가능) -> 클래스 수정이랑 뭐가 다르지? (계약서참고)
	 -> 반환값을 상세하게 정의하지 않는다. (설탕o 잘게빻은 흙설탕x)

Abstract class : protected abstract method(name:string):returnType;
스스로는 생성되지 못하며, interface와 마찬가지로 계약서혹은 설계서라고 보면 된다.
공통적인 함수들을 정의할수있으며, 객체마다 다르게 구현해야 하는 것또한 설정할 수 있는 클래스.
사용자가 사용할 함수 외에는 private으로 숨기며, 각 객체에서 구현해야하기때문에 접근해야하는 메소드의 경우 protected를 사용한다.

함수를 왜 내맘대로 수정을 못하지 → 매개변수는 같아야한다네.. 함수를 추가해줘야하네;

뭔가를 배울때는 상상력을 이용 (생활코딩님이 말하신것처럼 문제를 부풀려 상상.. 방대한 양의 코드)

계약서 : 같은 클래스를 재사용하며 원하는 부품을 넣어 다른 종류의 인스턴스(객체)를 생성한다.
 (즉 같은 클래스지만 부품에따라 다른 결과물 ⇒ 다른 종류의 부품(클래스)을 추가하기 위해서 인터페이스를 사용한다.) 
 **결론 ⇒ 객체가 아닌 문서(interface)를 통하여 상호작용한다 : )    #interface 간단하게.. placeholder라고 생각하자.**

 이득 ⇒ 한 종류의 클래스에(머신) 각자 다른 종류의 클래스(부품)을 끼워서 다른 결과물(인스턴스)을 생성한다.
             원래는 interface를 받은 기능의 class도 만들고, 머신의 class도 각자 전부 만들었는데, 머신을 하나로 퉁쳐서 결과물만 다르게 뽑으면 된다.
             (상속을 전혀 사용하지 않고도 다양한 형태의 Object를 생성할수있다.) 상속이 필요할때도 있지만 너무 깊게 가면 안된다.